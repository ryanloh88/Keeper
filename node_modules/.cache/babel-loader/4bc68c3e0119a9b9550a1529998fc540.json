{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridFSBucket = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst download_1 = require(\"./download\");\n\nconst upload_1 = require(\"./upload\");\n\nconst utils_1 = require(\"../utils\");\n\nconst write_concern_1 = require(\"../write_concern\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\n/**\n * Constructor for a streaming GridFS interface\n * @public\n */\n\nclass GridFSBucket extends mongo_types_1.TypedEventEmitter {\n  constructor(db, options) {\n    super();\n    this.setMaxListeners(0);\n    const privateOptions = { ...DEFAULT_GRIDFS_BUCKET_OPTIONS,\n      ...options,\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n    };\n    this.s = {\n      db,\n      options: privateOptions,\n      _chunksCollection: db.collection(privateOptions.bucketName + '.chunks'),\n      _filesCollection: db.collection(privateOptions.bucketName + '.files'),\n      checkedIndexes: false,\n      calledOpenUploadStream: false\n    };\n  }\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS. The stream's 'id' property contains the resulting\n   * file's id.\n   *\n   * @param filename - The value of the 'filename' key in the files doc\n   * @param options - Optional settings.\n   */\n\n\n  openUploadStream(filename, options) {\n    return new upload_1.GridFSBucketWriteStream(this, filename, options);\n  }\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n   * file's id.\n   */\n\n\n  openUploadStreamWithId(id, filename, options) {\n    return new upload_1.GridFSBucketWriteStream(this, filename, { ...options,\n      id\n    });\n  }\n  /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\n\n\n  openDownloadStream(id, options) {\n    return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {\n      _id: id\n    }, options);\n  }\n\n  delete(id, callback) {\n    return (0, utils_1.executeLegacyOperation)((0, utils_1.getTopology)(this.s.db), _delete, [this, id, callback], {\n      skipSessions: true\n    });\n  }\n  /** Convenience wrapper around find on the files collection */\n\n\n  find(filter, options) {\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.s._filesCollection.find(filter, options);\n  }\n  /**\n   * Returns a readable stream (GridFSBucketReadStream) for streaming the\n   * file with the given name from GridFS. If there are multiple files with\n   * the same name, this will stream the most recent file with the given name\n   * (as determined by the `uploadDate` field). You can set the `revision`\n   * option to change this behavior.\n   */\n\n\n  openDownloadStreamByName(filename, options) {\n    let sort = {\n      uploadDate: -1\n    };\n    let skip = undefined;\n\n    if (options && options.revision != null) {\n      if (options.revision >= 0) {\n        sort = {\n          uploadDate: 1\n        };\n        skip = options.revision;\n      } else {\n        skip = -options.revision - 1;\n      }\n    }\n\n    return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {\n      filename\n    }, { ...options,\n      sort,\n      skip\n    });\n  }\n\n  rename(id, filename, callback) {\n    return (0, utils_1.executeLegacyOperation)((0, utils_1.getTopology)(this.s.db), _rename, [this, id, filename, callback], {\n      skipSessions: true\n    });\n  }\n\n  drop(callback) {\n    return (0, utils_1.executeLegacyOperation)((0, utils_1.getTopology)(this.s.db), _drop, [this, callback], {\n      skipSessions: true\n    });\n  }\n  /** Get the Db scoped logger. */\n\n\n  getLogger() {\n    return this.s.db.s.logger;\n  }\n\n}\n\nexports.GridFSBucket = GridFSBucket;\n/**\n * When the first call to openUploadStream is made, the upload stream will\n * check to see if it needs to create the proper indexes on the chunks and\n * files collections. This event is fired either when 1) it determines that\n * no index creation is necessary, 2) when it successfully creates the\n * necessary indexes.\n * @event\n */\n\nGridFSBucket.INDEX = 'index';\n\nfunction _delete(bucket, id, callback) {\n  return bucket.s._filesCollection.deleteOne({\n    _id: id\n  }, (error, res) => {\n    if (error) {\n      return callback(error);\n    }\n\n    return bucket.s._chunksCollection.deleteMany({\n      files_id: id\n    }, error => {\n      if (error) {\n        return callback(error);\n      } // Delete orphaned chunks before returning FileNotFound\n\n\n      if (!(res === null || res === void 0 ? void 0 : res.deletedCount)) {\n        // TODO(NODE-3483): Replace with more appropriate error\n        // Consider creating new error MongoGridFSFileNotFoundError\n        return callback(new error_1.MongoRuntimeError(`File not found for id ${id}`));\n      }\n\n      return callback();\n    });\n  });\n}\n\nfunction _rename(bucket, id, filename, callback) {\n  const filter = {\n    _id: id\n  };\n  const update = {\n    $set: {\n      filename\n    }\n  };\n  return bucket.s._filesCollection.updateOne(filter, update, (error, res) => {\n    if (error) {\n      return callback(error);\n    }\n\n    if (!(res === null || res === void 0 ? void 0 : res.matchedCount)) {\n      return callback(new error_1.MongoRuntimeError(`File with id ${id} not found`));\n    }\n\n    return callback();\n  });\n}\n\nfunction _drop(bucket, callback) {\n  return bucket.s._filesCollection.drop(error => {\n    if (error) {\n      return callback(error);\n    }\n\n    return bucket.s._chunksCollection.drop(error => {\n      if (error) {\n        return callback(error);\n      }\n\n      return callback();\n    });\n  });\n}","map":{"version":3,"sources":["/Users/ryanlohyongrui/Documents/React.js/keeper-app/node_modules/mongodb/src/gridfs/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { MongoRuntimeError } from '../error';\nimport {\n  GridFSBucketReadStream,\n  GridFSBucketReadStreamOptions,\n  GridFSBucketReadStreamOptionsWithRevision,\n  GridFSFile\n} from './download';\nimport { GridFSBucketWriteStream, GridFSBucketWriteStreamOptions, GridFSChunk } from './upload';\nimport { executeLegacyOperation, Callback, getTopology } from '../utils';\nimport { WriteConcernOptions, WriteConcern } from '../write_concern';\nimport type { ObjectId } from '../bson';\nimport type { Db } from '../db';\nimport type { ReadPreference } from '../read_preference';\nimport type { Collection } from '../collection';\nimport type { FindOptions } from './../operations/find';\nimport type { Sort } from '../sort';\nimport type { Logger } from '../logger';\nimport type { FindCursor } from '../cursor/find_cursor';\nimport { Filter, TypedEventEmitter } from '../mongo_types';\n\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS: {\n  bucketName: string;\n  chunkSizeBytes: number;\n} = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\n\n/** @public */\nexport interface GridFSBucketOptions extends WriteConcernOptions {\n  /** The 'files' and 'chunks' collections will be prefixed with the bucket name followed by a dot. */\n  bucketName?: string;\n  /** Number of bytes stored in each chunk. Defaults to 255KB */\n  chunkSizeBytes?: number;\n  /** Read preference to be passed to read operations */\n  readPreference?: ReadPreference;\n}\n\n/** @internal */\nexport interface GridFSBucketPrivate {\n  db: Db;\n  options: {\n    bucketName: string;\n    chunkSizeBytes: number;\n    readPreference?: ReadPreference;\n    writeConcern: WriteConcern | undefined;\n  };\n  _chunksCollection: Collection<GridFSChunk>;\n  _filesCollection: Collection<GridFSFile>;\n  checkedIndexes: boolean;\n  calledOpenUploadStream: boolean;\n}\n\n/** @public */\nexport type GridFSBucketEvents = {\n  index(): void;\n};\n\n/**\n * Constructor for a streaming GridFS interface\n * @public\n */\nexport class GridFSBucket extends TypedEventEmitter<GridFSBucketEvents> {\n  /** @internal */\n  s: GridFSBucketPrivate;\n\n  /**\n   * When the first call to openUploadStream is made, the upload stream will\n   * check to see if it needs to create the proper indexes on the chunks and\n   * files collections. This event is fired either when 1) it determines that\n   * no index creation is necessary, 2) when it successfully creates the\n   * necessary indexes.\n   * @event\n   */\n  static readonly INDEX = 'index' as const;\n\n  constructor(db: Db, options?: GridFSBucketOptions) {\n    super();\n    this.setMaxListeners(0);\n    const privateOptions = {\n      ...DEFAULT_GRIDFS_BUCKET_OPTIONS,\n      ...options,\n      writeConcern: WriteConcern.fromOptions(options)\n    };\n    this.s = {\n      db,\n      options: privateOptions,\n      _chunksCollection: db.collection<GridFSChunk>(privateOptions.bucketName + '.chunks'),\n      _filesCollection: db.collection<GridFSFile>(privateOptions.bucketName + '.files'),\n      checkedIndexes: false,\n      calledOpenUploadStream: false\n    };\n  }\n\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS. The stream's 'id' property contains the resulting\n   * file's id.\n   *\n   * @param filename - The value of the 'filename' key in the files doc\n   * @param options - Optional settings.\n   */\n\n  openUploadStream(\n    filename: string,\n    options?: GridFSBucketWriteStreamOptions\n  ): GridFSBucketWriteStream {\n    return new GridFSBucketWriteStream(this, filename, options);\n  }\n\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n   * file's id.\n   */\n  openUploadStreamWithId(\n    id: ObjectId,\n    filename: string,\n    options?: GridFSBucketWriteStreamOptions\n  ): GridFSBucketWriteStream {\n    return new GridFSBucketWriteStream(this, filename, { ...options, id });\n  }\n\n  /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\n  openDownloadStream(\n    id: ObjectId,\n    options?: GridFSBucketReadStreamOptions\n  ): GridFSBucketReadStream {\n    return new GridFSBucketReadStream(\n      this.s._chunksCollection,\n      this.s._filesCollection,\n      this.s.options.readPreference,\n      { _id: id },\n      options\n    );\n  }\n\n  /**\n   * Deletes a file with the given id\n   *\n   * @param id - The id of the file doc\n   */\n  delete(id: ObjectId): Promise<undefined>;\n  delete(id: ObjectId, callback: Callback<void>): void;\n  delete(id: ObjectId, callback?: Callback<void>): Promise<undefined> | void {\n    return executeLegacyOperation(getTopology(this.s.db), _delete, [this, id, callback], {\n      skipSessions: true\n    });\n  }\n\n  /** Convenience wrapper around find on the files collection */\n  find(filter?: Filter<GridFSFile>, options?: FindOptions): FindCursor<GridFSFile> {\n    filter ??= {};\n    options = options ?? {};\n    return this.s._filesCollection.find(filter, options);\n  }\n\n  /**\n   * Returns a readable stream (GridFSBucketReadStream) for streaming the\n   * file with the given name from GridFS. If there are multiple files with\n   * the same name, this will stream the most recent file with the given name\n   * (as determined by the `uploadDate` field). You can set the `revision`\n   * option to change this behavior.\n   */\n  openDownloadStreamByName(\n    filename: string,\n    options?: GridFSBucketReadStreamOptionsWithRevision\n  ): GridFSBucketReadStream {\n    let sort: Sort = { uploadDate: -1 };\n    let skip = undefined;\n    if (options && options.revision != null) {\n      if (options.revision >= 0) {\n        sort = { uploadDate: 1 };\n        skip = options.revision;\n      } else {\n        skip = -options.revision - 1;\n      }\n    }\n    return new GridFSBucketReadStream(\n      this.s._chunksCollection,\n      this.s._filesCollection,\n      this.s.options.readPreference,\n      { filename },\n      { ...options, sort, skip }\n    );\n  }\n\n  /**\n   * Renames the file with the given _id to the given string\n   *\n   * @param id - the id of the file to rename\n   * @param filename - new name for the file\n   */\n  rename(id: ObjectId, filename: string): Promise<void>;\n  rename(id: ObjectId, filename: string, callback: Callback<void>): void;\n  rename(id: ObjectId, filename: string, callback?: Callback<void>): Promise<void> | void {\n    return executeLegacyOperation(getTopology(this.s.db), _rename, [this, id, filename, callback], {\n      skipSessions: true\n    });\n  }\n\n  /** Removes this bucket's files collection, followed by its chunks collection. */\n  drop(): Promise<void>;\n  drop(callback: Callback<void>): void;\n  drop(callback?: Callback<void>): Promise<void> | void {\n    return executeLegacyOperation(getTopology(this.s.db), _drop, [this, callback], {\n      skipSessions: true\n    });\n  }\n\n  /** Get the Db scoped logger. */\n  getLogger(): Logger {\n    return this.s.db.s.logger;\n  }\n}\n\nfunction _delete(bucket: GridFSBucket, id: ObjectId, callback: Callback<void>): void {\n  return bucket.s._filesCollection.deleteOne({ _id: id }, (error, res) => {\n    if (error) {\n      return callback(error);\n    }\n\n    return bucket.s._chunksCollection.deleteMany({ files_id: id }, error => {\n      if (error) {\n        return callback(error);\n      }\n\n      // Delete orphaned chunks before returning FileNotFound\n      if (!res?.deletedCount) {\n        // TODO(NODE-3483): Replace with more appropriate error\n        // Consider creating new error MongoGridFSFileNotFoundError\n        return callback(new MongoRuntimeError(`File not found for id ${id}`));\n      }\n\n      return callback();\n    });\n  });\n}\n\nfunction _rename(\n  bucket: GridFSBucket,\n  id: ObjectId,\n  filename: string,\n  callback: Callback<void>\n): void {\n  const filter = { _id: id };\n  const update = { $set: { filename } };\n  return bucket.s._filesCollection.updateOne(filter, update, (error?, res?) => {\n    if (error) {\n      return callback(error);\n    }\n\n    if (!res?.matchedCount) {\n      return callback(new MongoRuntimeError(`File with id ${id} not found`));\n    }\n\n    return callback();\n  });\n}\n\nfunction _drop(bucket: GridFSBucket, callback: Callback<void>): void {\n  return bucket.s._filesCollection.drop((error?: Error) => {\n    if (error) {\n      return callback(error);\n    }\n    return bucket.s._chunksCollection.drop((error?: Error) => {\n      if (error) {\n        return callback(error);\n      }\n\n      return callback();\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"script"}