{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompress = exports.compress = exports.uncompressibleCommands = exports.Compressor = void 0;\n\nconst zlib = require(\"zlib\");\n\nconst deps_1 = require(\"../../deps\");\n\nconst error_1 = require(\"../../error\");\n/** @public */\n\n\nexports.Compressor = Object.freeze({\n  none: 0,\n  snappy: 1,\n  zlib: 2\n});\nexports.uncompressibleCommands = new Set(['ismaster', 'saslStart', 'saslContinue', 'getnonce', 'authenticate', 'createUser', 'updateUser', 'copydbSaslStart', 'copydbgetnonce', 'copydb']); // Facilitate compressing a message using an agreed compressor\n\nfunction compress(self, dataToBeCompressed, callback) {\n  const zlibOptions = {};\n\n  switch (self.options.agreedCompressor) {\n    case 'snappy':\n      {\n        if ('kModuleError' in deps_1.Snappy) {\n          return callback(deps_1.Snappy['kModuleError']);\n        }\n\n        if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {\n          deps_1.Snappy.compress(dataToBeCompressed, callback);\n        } else {\n          deps_1.Snappy.compress(dataToBeCompressed).then(buffer => callback(undefined, buffer)).catch(error => callback(error));\n        }\n\n        break;\n      }\n\n    case 'zlib':\n      // Determine zlibCompressionLevel\n      if (self.options.zlibCompressionLevel) {\n        zlibOptions.level = self.options.zlibCompressionLevel;\n      }\n\n      zlib.deflate(dataToBeCompressed, zlibOptions, callback);\n      break;\n\n    default:\n      throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${self.options.agreedCompressor} failed to compress`);\n  }\n}\n\nexports.compress = compress; // Decompress a message using the given compressor\n\nfunction decompress(compressorID, compressedData, callback) {\n  if (compressorID < 0 || compressorID > Math.max(2)) {\n    throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);\n  }\n\n  switch (compressorID) {\n    case exports.Compressor.snappy:\n      {\n        if ('kModuleError' in deps_1.Snappy) {\n          return callback(deps_1.Snappy['kModuleError']);\n        }\n\n        if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {\n          deps_1.Snappy.uncompress(compressedData, {\n            asBuffer: true\n          }, callback);\n        } else {\n          deps_1.Snappy.uncompress(compressedData, {\n            asBuffer: true\n          }).then(buffer => callback(undefined, buffer)).catch(error => callback(error));\n        }\n\n        break;\n      }\n\n    case exports.Compressor.zlib:\n      zlib.inflate(compressedData, callback);\n      break;\n\n    default:\n      callback(undefined, compressedData);\n  }\n}\n\nexports.decompress = decompress;","map":{"version":3,"sources":["/Users/ryanlohyongrui/Documents/React.js/keeper-app/node_modules/mongodb/src/cmap/wire_protocol/compression.ts"],"names":[],"mappings":"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","sourcesContent":["import * as zlib from 'zlib';\nimport type { Callback } from '../../utils';\nimport type { OperationDescription } from '../message_stream';\n\nimport { PKG_VERSION, Snappy } from '../../deps';\nimport { MongoDecompressionError, MongoInvalidArgumentError } from '../../error';\n\n/** @public */\nexport const Compressor = Object.freeze({\n  none: 0,\n  snappy: 1,\n  zlib: 2\n} as const);\n\n/** @public */\nexport type Compressor = typeof Compressor[CompressorName];\n\n/** @public */\nexport type CompressorName = keyof typeof Compressor;\n\nexport const uncompressibleCommands = new Set([\n  'ismaster',\n  'saslStart',\n  'saslContinue',\n  'getnonce',\n  'authenticate',\n  'createUser',\n  'updateUser',\n  'copydbSaslStart',\n  'copydbgetnonce',\n  'copydb'\n]);\n\n// Facilitate compressing a message using an agreed compressor\nexport function compress(\n  self: { options: OperationDescription & zlib.ZlibOptions },\n  dataToBeCompressed: Buffer,\n  callback: Callback<Buffer>\n): void {\n  const zlibOptions = {} as zlib.ZlibOptions;\n  switch (self.options.agreedCompressor) {\n    case 'snappy': {\n      if ('kModuleError' in Snappy) {\n        return callback(Snappy['kModuleError']);\n      }\n\n      if (Snappy[PKG_VERSION].major <= 6) {\n        Snappy.compress(dataToBeCompressed, callback);\n      } else {\n        Snappy.compress(dataToBeCompressed)\n          .then(buffer => callback(undefined, buffer))\n          .catch(error => callback(error));\n      }\n      break;\n    }\n    case 'zlib':\n      // Determine zlibCompressionLevel\n      if (self.options.zlibCompressionLevel) {\n        zlibOptions.level = self.options.zlibCompressionLevel;\n      }\n      zlib.deflate(dataToBeCompressed, zlibOptions, callback as zlib.CompressCallback);\n      break;\n    default:\n      throw new MongoInvalidArgumentError(\n        `Unknown compressor ${self.options.agreedCompressor} failed to compress`\n      );\n  }\n}\n\n// Decompress a message using the given compressor\nexport function decompress(\n  compressorID: Compressor,\n  compressedData: Buffer,\n  callback: Callback<Buffer>\n): void {\n  if (compressorID < 0 || compressorID > Math.max(2)) {\n    throw new MongoDecompressionError(\n      `Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`\n    );\n  }\n\n  switch (compressorID) {\n    case Compressor.snappy: {\n      if ('kModuleError' in Snappy) {\n        return callback(Snappy['kModuleError']);\n      }\n\n      if (Snappy[PKG_VERSION].major <= 6) {\n        Snappy.uncompress(compressedData, { asBuffer: true }, callback);\n      } else {\n        Snappy.uncompress(compressedData, { asBuffer: true })\n          .then(buffer => callback(undefined, buffer))\n          .catch(error => callback(error));\n      }\n      break;\n    }\n    case Compressor.zlib:\n      zlib.inflate(compressedData, callback as zlib.CompressCallback);\n      break;\n    default:\n      callback(undefined, compressedData);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}