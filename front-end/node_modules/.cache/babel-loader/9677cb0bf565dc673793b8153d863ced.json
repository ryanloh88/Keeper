{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst operation_1 = require(\"./operation\");\n\nconst command_1 = require(\"./command\");\n\nconst common_functions_1 = require(\"./common_functions\");\n\nconst write_concern_1 = require(\"../write_concern\");\n\nconst bulk_write_1 = require(\"./bulk_write\");\n/** @internal */\n\n\nclass InsertOperation extends command_1.CommandOperation {\n  constructor(ns, documents, options) {\n    var _a;\n\n    super(undefined, options);\n    this.options = { ...options,\n      checkKeys: (_a = options.checkKeys) !== null && _a !== void 0 ? _a : false\n    };\n    this.ns = ns;\n    this.documents = documents;\n  }\n\n  execute(server, session, callback) {\n    var _a;\n\n    const options = (_a = this.options) !== null && _a !== void 0 ? _a : {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command = {\n      insert: this.ns.collection,\n      documents: this.documents,\n      ordered\n    };\n\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    if (options.comment != null) {\n      command.comment = options.comment;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n\n}\n\nexports.InsertOperation = InsertOperation;\n\nclass InsertOneOperation extends InsertOperation {\n  constructor(collection, doc, options) {\n    super(collection.s.namespace, (0, common_functions_1.prepareDocs)(collection, [doc], options), options);\n  }\n\n  execute(server, session, callback) {\n    super.execute(server, session, (err, res) => {\n      var _a, _b;\n\n      if (err || res == null) return callback(err);\n      if (res.code) return callback(new error_1.MongoServerError(res));\n\n      if (res.writeErrors) {\n        // This should be a WriteError but we can't change it now because of error hierarchy\n        return callback(new error_1.MongoServerError(res.writeErrors[0]));\n      }\n\n      callback(undefined, {\n        acknowledged: (_b = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,\n        insertedId: this.documents[0]._id\n      });\n    });\n  }\n\n}\n\nexports.InsertOneOperation = InsertOneOperation;\n/** @internal */\n\nclass InsertManyOperation extends operation_1.AbstractOperation {\n  constructor(collection, docs, options) {\n    super(options);\n\n    if (!Array.isArray(docs)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n    }\n\n    this.options = options;\n    this.collection = collection;\n    this.docs = docs;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const options = { ...this.options,\n      ...this.bsonOptions,\n      readPreference: this.readPreference\n    };\n    const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n    const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, (0, common_functions_1.prepareDocs)(coll, this.docs, options).map(document => ({\n      insertOne: {\n        document\n      }\n    })), options);\n    bulkWriteOperation.execute(server, session, (err, res) => {\n      var _a;\n\n      if (err || res == null) return callback(err);\n      callback(undefined, {\n        acknowledged: (_a = (writeConcern === null || writeConcern === void 0 ? void 0 : writeConcern.w) !== 0) !== null && _a !== void 0 ? _a : true,\n        insertedCount: res.insertedCount,\n        insertedIds: res.insertedIds\n      });\n    });\n  }\n\n}\n\nexports.InsertManyOperation = InsertManyOperation;\n(0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"sources":["/Users/ryanlohyongrui/Documents/React.js/keeper-app/node_modules/mongodb/src/operations/insert.ts"],"names":[],"mappings":"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","sourcesContent":["import { MongoServerError, MongoInvalidArgumentError } from '../error';\nimport { defineAspects, Aspect, AbstractOperation } from './operation';\nimport { CommandOperation, CommandOperationOptions } from './command';\nimport { prepareDocs } from './common_functions';\nimport type { Callback, MongoDBNamespace } from '../utils';\nimport type { Server } from '../sdam/server';\nimport type { Collection } from '../collection';\nimport type { Document } from '../bson';\nimport type { BulkWriteOptions } from '../bulk/common';\nimport { WriteConcern } from '../write_concern';\nimport type { ClientSession } from '../sessions';\nimport { BulkWriteOperation } from './bulk_write';\nimport type { InferIdType } from '../mongo_types';\n\n/** @internal */\nexport class InsertOperation extends CommandOperation<Document> {\n  options: BulkWriteOptions;\n  documents: Document[];\n\n  constructor(ns: MongoDBNamespace, documents: Document[], options: BulkWriteOptions) {\n    super(undefined, options);\n    this.options = { ...options, checkKeys: options.checkKeys ?? false };\n    this.ns = ns;\n    this.documents = documents;\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<Document>): void {\n    const options = this.options ?? {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command: Document = {\n      insert: this.ns.collection,\n      documents: this.documents,\n      ordered\n    };\n\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    if (options.comment != null) {\n      command.comment = options.comment;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n}\n\n/** @public */\nexport interface InsertOneOptions extends CommandOperationOptions {\n  /** Allow driver to bypass schema validation in MongoDB 3.2 or higher. */\n  bypassDocumentValidation?: boolean;\n  /** Force server to assign _id values instead of driver. */\n  forceServerObjectId?: boolean;\n}\n\n/** @public */\nexport interface InsertOneResult<TSchema = Document> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The identifier that was inserted. If the server generated the identifier, this value will be null as the driver does not have access to that data */\n  insertedId: InferIdType<TSchema>;\n}\n\nexport class InsertOneOperation extends InsertOperation {\n  constructor(collection: Collection, doc: Document, options: InsertOneOptions) {\n    super(collection.s.namespace, prepareDocs(collection, [doc], options), options);\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<InsertOneResult>): void {\n    super.execute(server, session, (err, res) => {\n      if (err || res == null) return callback(err);\n      if (res.code) return callback(new MongoServerError(res));\n      if (res.writeErrors) {\n        // This should be a WriteError but we can't change it now because of error hierarchy\n        return callback(new MongoServerError(res.writeErrors[0]));\n      }\n\n      callback(undefined, {\n        acknowledged: this.writeConcern?.w !== 0 ?? true,\n        insertedId: this.documents[0]._id\n      });\n    });\n  }\n}\n\n/** @public */\nexport interface InsertManyResult<TSchema = Document> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The number of inserted documents for this operations */\n  insertedCount: number;\n  /** Map of the index of the inserted document to the id of the inserted document */\n  insertedIds: { [key: number]: InferIdType<TSchema> };\n}\n\n/** @internal */\nexport class InsertManyOperation extends AbstractOperation<InsertManyResult> {\n  options: BulkWriteOptions;\n  collection: Collection;\n  docs: Document[];\n\n  constructor(collection: Collection, docs: Document[], options: BulkWriteOptions) {\n    super(options);\n\n    if (!Array.isArray(docs)) {\n      throw new MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n    }\n\n    this.options = options;\n    this.collection = collection;\n    this.docs = docs;\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<InsertManyResult>): void {\n    const coll = this.collection;\n    const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };\n    const writeConcern = WriteConcern.fromOptions(options);\n    const bulkWriteOperation = new BulkWriteOperation(\n      coll,\n      prepareDocs(coll, this.docs, options).map(document => ({ insertOne: { document } })),\n      options\n    );\n\n    bulkWriteOperation.execute(server, session, (err, res) => {\n      if (err || res == null) return callback(err);\n      callback(undefined, {\n        acknowledged: writeConcern?.w !== 0 ?? true,\n        insertedCount: res.insertedCount,\n        insertedIds: res.insertedIds\n      });\n    });\n  }\n}\n\ndefineAspects(InsertOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\ndefineAspects(InsertOneOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\ndefineAspects(InsertManyOperation, [Aspect.WRITE_OPERATION]);\n"]},"metadata":{},"sourceType":"script"}